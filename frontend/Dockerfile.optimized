FROM node:18-alpine as base

# Install system dependencies
RUN apk add --no-cache curl

WORKDIR /app

# ===== DEPENDENCY STAGE =====
FROM base as dependencies

# Copy package files first (for better caching)
COPY package*.json ./

# Install dependencies with npm cache
RUN --mount=type=cache,target=/root/.npm \
    npm ci --only=production --silent

# Install dev dependencies in development
FROM dependencies as development-deps
RUN --mount=type=cache,target=/root/.npm \
    npm ci --silent

# ===== DEVELOPMENT STAGE =====
FROM development-deps as development

# Copy source code
COPY . .

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:3000 || exit 1

EXPOSE 3000
CMD ["npm", "run", "dev"]

# ===== SMART BUILD SCRIPT =====
#!/usr/bin/env python3
"""
Smart Docker Compose Build Script
Only rebuilds what's necessary based on file changes
"""

import subprocess
import hashlib
import json
from pathlib import Path
from typing import Dict, List, Optional

class SmartBuilder:
    def __init__(self):
        self.cache_file = Path(".build_cache.json")
        self.compose_file = "docker/docker-compose.dev.yml"
        
    def get_file_hash(self, file_path: Path) -> str:
        """Get hash of file content"""
        if not file_path.exists():
            return ""
        return hashlib.md5(file_path.read_bytes()).hexdigest()
    
    def get_directory_hash(self, dir_path: Path, patterns: List[str]) -> str:
        """Get hash of directory content matching patterns"""
        hash_content = ""
        for pattern in patterns:
            for file_path in dir_path.glob(pattern):
                if file_path.is_file():
                    hash_content += self.get_file_hash(file_path)
        return hashlib.md5(hash_content.encode()).hexdigest()
    
    def load_cache(self) -> Dict:
        """Load build cache"""
        if self.cache_file.exists():
            return json.loads(self.cache_file.read_text())
        return {}
    
    def save_cache(self, cache: Dict):
        """Save build cache"""
        self.cache_file.write_text(json.dumps(cache, indent=2))
    
    def needs_rebuild(self, service: str) -> bool:
        """Check if service needs rebuild"""
        cache = self.load_cache()
        
        if service == "backend":
            # Check backend files
            current_hashes = {
                "requirements": self.get_file_hash(Path("backend/requirements.txt")),
                "dockerfile": self.get_file_hash(Path("backend/Dockerfile.optimized")),
                "app_code": self.get_directory_hash(Path("backend/app"), ["**/*.py"])
            }
        elif service == "frontend":
            # Check frontend files
            current_hashes = {
                "package_json": self.get_file_hash(Path("frontend/package.json")),
                "package_lock": self.get_file_hash(Path("frontend/package-lock.json")),
                "dockerfile": self.get_file_hash(Path("frontend/Dockerfile.optimized")),
                "app_code": self.get_directory_hash(Path("frontend/src"), ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"])
            }
        else:
            return False
        
        # Compare with cached hashes
        cached_hashes = cache.get(service, {})
        
        for key, current_hash in current_hashes.items():
            if cached_hashes.get(key) != current_hash:
                print(f"üîÑ {service}: {key} changed, rebuild needed")
                # Update cache
                cache[service] = current_hashes
                self.save_cache(cache)
                return True
        
        print(f"‚úÖ {service}: No changes detected, using cache")
        return False
    
    def build_service(self, service: str):
        """Build specific service"""
        print(f"üî® Building {service}...")
        
        cmd = [
            "docker", "compose", "-f", self.compose_file,
            "build", "--pull", service
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            print(f"‚úÖ {service} built successfully")
        else:
            print(f"‚ùå {service} build failed:")
            print(result.stderr)
    
    def smart_build(self):
        """Perform smart build of all services"""
        print("üöÄ Smart Docker Compose Build")
        print("="*40)
        
        services = ["backend", "frontend"]
        services_to_build = []
        
        for service in services:
            if self.needs_rebuild(service):
                services_to_build.append(service)
        
        if not services_to_build:
            print("‚úÖ No services need rebuilding")
            print("Starting existing containers...")
            subprocess.run([
                "docker", "compose", "-f", self.compose_file, "up", "-d"
            ])
        else:
            print(f"üî® Building services: {', '.join(services_to_build)}")
            
            # Build only changed services
            for service in services_to_build:
                self.build_service(service)
            
            # Start all services
            print("üöÄ Starting all services...")
            subprocess.run([
                "docker", "compose", "-f", self.compose_file, "up", "-d"
            ])

if __name__ == "__main__":
    builder = SmartBuilder()
    builder.smart_build()
